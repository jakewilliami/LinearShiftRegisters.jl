var documenterSearchIndex = {"docs":
[{"location":"#Home","page":"Index","title":"Home","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"See here and here for an explanation of the functions in this package.","category":"page"},{"location":"","page":"Index","title":"Index","text":"Randomness is very hard for a computer to get right.  This is why there are many tools to produce what we call pseudo-random generators (from which pseudo-random strings and -numbers come).  These look random; you would expect them to be somehow \"patternless\".  But how would you test if these are random?","category":"page"},{"location":"","page":"Index","title":"Index","text":"Kolmogorov proposed the following definition of a random string:","category":"page"},{"location":"","page":"Index","title":"Index","text":"A sequence is random if it cannot be generated by an algorithm with a description much shorter than the sequence itself.","category":"page"},{"location":"","page":"Index","title":"Index","text":"Obviously the sequence of all 1’s is not random according to the above definition, nor are the first n digits of π.  In fact, it is very hard to describe a random string in Kolmogorov’s sense.  An alternative is to try to generate a sequence that has some desirable features of a random string. Such sequences are often called pseudo-random sequences.  What we would like is to be able to generate a sequence that could be used like a one-time pad without the inconvenience of having to store the whole sequence.","category":"page"},{"location":"","page":"Index","title":"Index","text":"There are many different techniques to create pseudo-random generators. This repository gives just a couple of those methods, in a nice little package.","category":"page"},{"location":"#Contents","page":"Index","title":"Contents","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"","category":"page"},{"location":"","page":"Index","title":"Index","text":"CurrentModule = LinearShiftRegisters\nDocTestSetup = quote\n    using LinearShiftRegisters\nend","category":"page"},{"location":"#Adding-LinearShiftRegisters.jl","page":"Index","title":"Adding LinearShiftRegisters.jl","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"using Pkg\nPkg.add(\"LinearShiftRegisters\")","category":"page"},{"location":"#Documentation","page":"Index","title":"Documentation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Modules = [LinearShiftRegisters]","category":"page"},{"location":"#Main.LinearShiftRegisters.LCG_period-NTuple{4,Integer}","page":"Index","title":"Main.LinearShiftRegisters.LCG_period","text":"LCG_period(m::Integer, a::Integer, b::Integer, x0::Integer) -> String\n\nGiven m, a, b, and x0, finds the period generated by these parameters from a Linear Congruential Generator, and returns this sequence as a string.\n\nnote: Note\nAs this method looks for recurring sequences, it is possible that this function does not terminate—or maybe it does terminate, but I haven't waited long enough to find out.\n\n\n\nDescription\n\nChoose m, a positive integer.  Choose a, b (mod m) integers.\n\nThe Linear Congruential Generator is given to us by\n\nx_1 equiv ax_0+bmod m\nx_2 equiv ax_1+bmod m\nvdots\nx_n + 1 equiv ax_n + b mod m\nvdots\n\nEventually, x_n = x_i for some n, i (let's suppose ni and i is not necessarily 0).  Then, clearly,\n\nx_n+1 = x_i+1ldots\n\nSo\n\nx_i x_i+1dots x_n-1\n\nWill be repeated forever.\n\nFrom a cryptography point of view, LCG is too vulnerable (although all pseudorandom number generators are vulnerable), but it is still useful for other perposes that require pseudorandom numbers.\n\nFor essentially a more sophisticated version of LCG in the sense that it is based on recurring linear relations, see LSR_period.\n\n\n\nExamples\n\njulia> println(LinearShiftRegisters._LCG_period(9, 5, 2, 0))\n[0, 2, 3, 8, 6, 5]\n\njulia> LCG_period(9, 5, 2, 0)\n\"023865\"\n\n\n\n\n\n","category":"method"},{"location":"#Main.LinearShiftRegisters.LSR_period-Union{Tuple{R}, Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{R,1}}} where R<:Integer where T","page":"Index","title":"Main.LinearShiftRegisters.LSR_period","text":"LSR_period(const_str::AbstractVector{T}, init_str::AbstractVector{R}) where {T, R <: Integer} -> AbstractVector\nLSR_period(const_str::AbstractString, init_str::AbstractString) -> String\n\nGiven a starting binary string (init_str) and a constant mutating string (const_str), LSR_period will find the repeating sequence generated from these.\n\nnote: Note\nAs this method looks for recurring sequences, it is possible that this function does not terminate—or maybe it does terminate, but I haven't waited long enough to find out.\n\n\n\nDescription\n\nA (linear) shift register with feedback is an arrangement of registers in a row, each register being capable of holding either the digit 1 (on) or 0 (off).  Suppose the system has n registers, R_1ldotsR_n, and X_i(t) denotes the content of register R_i at time t.  Initially, let the system be given\n\nGiven\n\nExamples\n\njulia> LSR_period(\"1001\", \"0100\")\n\"001000111101011\"\n\njulia> LSR_period(\"1001\", \"0101\")\n\"101011001000111\"\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"","category":"page"}]
}
